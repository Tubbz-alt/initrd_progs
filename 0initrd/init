#!/bin/sh

if [ "$(ls /proc)" = "" ]; then
 mount -t proc none /proc
 mount -t sysfs none /sys
 mount -t rootfs -o remount,rw rootfs /
 ln -s /proc/mounts /etc/mtab
fi

export LANG=C #w004
. /DISTRO_SPECS #v412 has DISTRO_VERSION, DISTRO_FILE_PREFIX
[ ! "$DISTRO_DB_SUBNAME" ] && DISTRO_DB_SUBNAME="$DISTRO_COMPAT_VERSION" #121102 fallback if DISTRO_DB_SUBNAME not defined in file DISTRO_SPECS.

PATH="/bin:/sbin"
KERNELVER="$(uname -r)"

# always use DEVTMPFS now.
mount -t devtmpfs devtmpfs /dev
DEVTMPFSFLG=1 #130618 set it from 3builddistro.

#100911 simple filenames specified in DISTRO_SPECS: DISTRO_ZDRVSFS, DISTRO_PUPPYSFS...
Z_DEF_FN="$DISTRO_ZDRVSFS"
F_DEF_FN="$DISTRO_FDRVSFS"
A_DEF_FN="$DISTRO_ADRVSFS"
Y_DEF_FN="$DISTRO_YDRVSFS"
P_DEF_FN="$DISTRO_PUPPYSFS"

[ $loglevel ] && LOGLEVEL=$loglevel #v2.22

mntfunc() {
 MNT_T="$1"    #ex: vfat
 MNT_DEV="$2"  #ex: /dev/sda1
 MNT_DIR="$3"  #ex: /mnt/sda1
 MNT_O=""
 [ $4 ] && MNT_O="${4}" #ex: noatime
 case $MNT_T in
  ntfs)
   ntfs-3g $MNT_DEV $MNT_DIR -o umask=0,no_def_opts,noatime,rw,silent 2>/dev/null #default is rw. 130211 add silent.
   ntfsRETVAL=$?
   [ $ntfsRETVAL -eq 0 ] && return 0
   if [ $ntfsRETVAL -eq 14 ];then
    echo -e "\\033[1;31m" >/dev/console #31=red
    echo -n "ERROR: Windows NTFS hibernated partition, cannot mount" > /dev/console
    echo -e "\\033[0;39m" >/dev/console
    return 14
   else
    ntfs-3g $MNT_DEV $MNT_DIR -o umask=0,no_def_opts,noatime,rw,force,silent 2>/dev/null #130211 add silent.
   fi
  ;;
  vfat)
   mount -t $MNT_T -o $VFAT_OUT_PARAM $MNT_DEV $MNT_DIR
  ;;
  *)
   if [ "$MNT_O" = "" ];then
    mount -t $MNT_T $MNT_DEV $MNT_DIR
   else
    mount -t $MNT_T -o $MNT_O $MNT_DEV $MNT_DIR
   fi
  ;;
 esac
 return $?
}

decode_spec() {
 ONE_BP_ID=""; ONE_BP_FN=""
 [ "${1}" ] || return
 ONE_BP_ID="$(echo "$1" | cut -f 1 -d ':')"
 ONE_BP_FN="$(echo "$1" | cut -f 2 -d ':')"
 [ "$ONE_BP_FN" = "$ONE_BP_ID" ] && ONE_BP_FN=""
 [ "$ONE_BP_FN" ] && [ "${ONE_BP_FN:0:1}" != "/" ] && ONE_BP_FN="$PSUBDIR/$ONE_BP_FN"
}

decode_id() {
 ONE_PART=""
 [ "${1}" ] || return
 if [ "$(echo -n ${1} | grep -E '^[a-z]+[0-9]')" -a "$(grep -m1 "${1}$" /proc/partitions)" ];then
  ONE_PART="$1"  #is a real partition
 else
  [ "$BLKIDOUT" ] || BLKIDOUT="$(blkid)"
  ONE_PART="$(echo "$BLKIDOUT" | grep -m1 -E "LABEL=.${1}|UUID=.${1}" | cut -f1 -d: | cut -f3 -d/)" #is LABEL or UUID
 fi
}

decode_all_ids() {
 #get ONE_PART from DEV or ID specified in sfs boot params
 BLKIDOUT=""
 decode_id "$P_BP_ID"
 [ "$ONE_PART" ] && { P_PART="$ONE_PART"; P_BP_ID=""; }
 decode_id "$Z_BP_ID"
 [ "$ONE_PART" ] && { Z_PART="$ONE_PART"; Z_BP_ID=""; }
 decode_id "$F_BP_ID"
 [ "$ONE_PART" ] && { F_PART="$ONE_PART"; F_BP_ID=""; }
 decode_id "$A_BP_ID"
 [ "$ONE_PART" ] && { A_PART="$ONE_PART"; A_BP_ID=""; }
 decode_id "$Y_BP_ID"
 [ "$ONE_PART" ] && { Y_PART="$ONE_PART"; Y_BP_ID=""; }
 decode_id "$SAVE_BP_ID"
 [ "$ONE_PART" ] && { SAVEPART="$ONE_PART"; PSAVEPART="$ONE_PART"; SAVE_BP_ID=""; }
}

ensure_mounted() {
# "$1" - partition - ex: sda3
# "$2" - mountpoint - ex: /mnt/pdrv
 ONE_MP="$(mount | grep -m1 "/dev/${1} " | cut -f 3 -d ' ')"
 [ "$ONE_MP" ] && return
 ONE_FS="$(echo "$USE_PARTS" | grep "${1}" | cut -f 2 -d '|')"
 ONE_MP="${2}"
 [ -d "$ONE_MP" ] || mkdir -p $ONE_MP
 mntfunc $ONE_FS /dev/${1} $ONE_MP #-t $ONE_FS /dev/$ONE_PART $ONE_MP
 [ $? -eq 0 ] || ONE_MP=""
}

ensure_save_mounted() {
 ensure_mounted "$SAVEPART" "$SAVE_MP"
 if [ "$ONE_MP" ];then
  if [ "$ONE_MP" != "$SAVE_MP" ];then
   mount -o move $ONE_MP $SAVE_MP
   [ $? -eq 0 ] || SAVE_MP=""
  fi
 else
  SAVE_MP=""
 fi
 [ "$SAVE_MP" ] && SAVE_FS="$ONE_FS"
}

find_onepupdrv() {
# "$1" - partition - ex: sda3
# "$2" - specified filename - ex: /pup/mydrv-1.2.3.sfs
# "$3" - default filename - ex: adrv_tahr_6.0.5.sfs
# "$4" - prefix for "drv" mountpoint - ex: a
 ONE_FN=""
 [ "${2}" ] || [ "${3}" ] || return
 [ "${4}" ] || return
 if [ "${1}" ];then
  ONE_PART="${1}"
 else
  ONE_PART="$P_PART"
 fi
 [ "$ONE_PART" ] || return
 if [ "${2}" ];then
  ONE_TRY_FN="${2}"
 else
  ONE_TRY_FN="${PSUBDIR}/${3}"
 fi
 ensure_mounted "$ONE_PART" "/mnt/${4}drv"
 [ "$ONE_MP" ] || return
 if [ -f "${ONE_MP}${ONE_TRY_FN}" ];then
  ONE_FN="$ONE_TRY_FN"
 else
  [ "${2}" ] && echo "$ONE_PART, $ONE_TRY_FN file not found." >> /tmp/bootinit.log
 fi
}

load_onepupdrv() {
# "$1" - sfs spec - ex: sdb2,ext4,/pup/mydrv-1.2.3.sfs
# "$2" - suffix for "pup_" branch directory - ex: a
# "$3" - prepend after rw layer indicator - ex: p
 ONE_LAYER=""
 SFS_ERR=""
 [ "$1" ] || return
 [ "$2" ] || return
 ONE_PART="$(echo "${1}" | cut -f 1 -d ',')"
 [ "$ONE_PART" ] || return
 ONE_REL_FN="$(echo "${1}" | cut -f 3 -d ',')"
 [ "$ONE_REL_FN" ] || return
 ONE_SFX="${2}"
 ONE_PREP="${3}"
 SFS_ERR="1"
 if [ "$ONE_PART" = "rootfs" ];then #humongous initrd.
  ONE_MP="" #actually it's '/'.
  COPY2RAM='yes' #actually it is already in ram, but code below puts it in a tmpfs.
 else
  if [ "$ONE_PART" = "$P_PART" ];then
   ONE_MP="$P_MP"
  else
   ONE_MP="$(mount | grep -m1 "/dev/$ONE_PART " | cut -f 3 -d ' ')"
   [ "$ONE_MP" ] || return
  fi
 fi
 ONE_FN="${ONE_MP}${ONE_REL_FN}"
 [ -s "$ONE_FN" ] || return #sfs not Ok
 ONE_BASENAME="$(basename $ONE_REL_FN)"
 [ "$LOADMSG" ] && echo -n "Loading the '${ONE_BASENAME}' ${LOADMSG} file..." > /dev/console
 if [ "$COPY2RAM" = "" ];then
  COPY2RAM="no"
  #if there's heaps of ram, copy puppy.sfs to a tmpfs...
  #v405 fast media plus more than 256MB ram then definitely worth copying to ram...
  SIZESFSK=$(du -k $ONE_FN | cut -f 1)
  SIZESFSK=$(($SIZESFSK + 1000)) #some slack.
  MINRAM2CPY=$(($SIZESFSK * 2)) #100222 technosaurus: in case of very big puppies.
  #decide whether to copy .sfs's to ram
  [ "$PNOCOPY" = "yes" ] || COPYCONTENDER='yes'
  [ "$PCOPY" = "yes" ] && COPYCONTENDER='yes'
  [ "$PRAMONLY" = "yes" ] && COPYCONTENDER='yes'
  [ "$COPYCONTENDER" = "yes" ] && [ $RAMSIZE -gt 400000 ] && [ $RAMSIZE -gt $MINRAM2CPY ] && COPY2RAM="yes"
 fi
 ONE_LOOP="$(losetup -f)"
 if [ "$COPY2RAM" = "yes" ];then
  SIZEZK=$(du -k $ONE_FN | cut -f 1)
  TFREEK=$(df | grep -m1 ' /mnt/tmpfs' | tr -s ' ' | cut -f 4 -d ' ')
  if [ $TFREEK -gt $SIZEZK ];then
   if [ "$ONE_MP" = "" ];then #101101 humongous initrd.
    mv -af $ONE_FN /mnt/tmpfs/
   else
    [ "$LOADMSG" ] && [ "$COPYMSG" ] && echo -e -n " \\033[1;35m${COPYMSG}\\033[0;39m" > /dev/console #purple.
    cp -af $ONE_FN /mnt/tmpfs/
   fi
   sync
   losetup $ONE_LOOP /mnt/tmpfs/$ONE_BASENAME
  else
   losetup $ONE_LOOP $ONE_FN
   [ "$ONE_PART" != "rootfs" ] && KEEPMOUNTED="${KEEPMOUNTED}${ONE_PART} "
  fi
 else
  losetup $ONE_LOOP $ONE_FN
  [ "$ONE_PART" != "rootfs" ] && KEEPMOUNTED="${KEEPMOUNTED}${ONE_PART} "
 fi
[ "$LOADMSG" ] && echo "" > /dev/console
 SFS_MP="/pup_${ONE_SFX}"
 [ "$ONE_SFX" = "p" ] && SFS_MP="/pup_ro2"
 [ -d "$SFS_MP" ] || mkdir $SFS_MP
 mount -r -t squashfs -o noatime $ONE_LOOP $SFS_MP > /dev/console 2>&1
 [ $? -eq 0 ] || return
 ONE_LAYER="$SFS_MP=ro"
 SFS_ERR="2"
 if [ "$(ls /pup_new)" = "" ];then #no aufs stack yet
  if [ "$ONE_SFX" = "p" ];then #create stack
   [ -d "/mnt/tmpfs/pup_rw" ] || mkdir /mnt/tmpfs/pup_rw
   mount -t aufs -o udba=reval,diropq=w,br=/mnt/tmpfs/pup_rw=rw:$ONE_LAYER,xino=/mnt/tmpfs/.aufs.xino unionfs /pup_new 
   [ $? -eq 0 ] || return
  else
   return
  fi
 elif [ "$ONE_PREP" ];then
  mount -o remount,add:1:$ONE_LAYER /pup_new
  [ $? -eq 0 ] || return
 else
  mount -o remount,append:$ONE_LAYER /pup_new
  [ $? -eq 0 ] || return
 fi
 NEWUNIONRECORD="${NEWUNIONRECORD}${ONE_BASENAME} "
 SFS_ERR=""
}

load_ext_file(){
  ONE_LOOP="$(losetup -f)"
  losetup $ONE_LOOP $SAVE_FN
  SFFS='ext'$(echo -n "$SAVE_FN" | rev | cut -c 3)
  [ -d "$SAVE_LAYER" ] || mkdir $SAVE_LAYER
  mount -t $SFFS -o noatime $ONE_LOOP $SAVE_LAYER
  [ $? -eq 0 ] || PUPSAVE=""  
}

load_save_file(){
 SAVE_REL_FN="$(echo "$PUPSAVE" | cut -f 3 -d ',')"
 echo "Loading personal storage $SAVE_REL_FN ($SAVEPART)..." > /dev/console 
 SAVE_FN="${SAVE_MP}${SAVE_REL_FN}"
 if [ -d "$SAVE_FN" ];then #savefolder
  rm -r -f $SAVE_LAYER
  ln -s $SAVE_FN $SAVE_LAYER
 elif [ -f "$SAVE_FN" ];then #savefile
  load_ext_file
 else
  PUPMODE=5
  PUPSAVE=""
  SAVE_MP=""
  SAVE_LAYER=""
 fi
}

load_save_part() {
 rm -r -f $SAVE_LAYER
 ln -s $SAVE_MP $SAVE_LAYER
}

copy_folders() {
 DESTDIR="/mnt/tmpfs/pup_ro1"
 [ -d "$DESTDIR" ] || mkdir -p $DESTDIR
 ln -s $DESTDIR $SAVE_LAYER
 BKFOLDERS="$(ls -1 -r $SAVE_MP | grep '^20[0-9][0-9]')"
}

prepend_dir() {
 rm -r -f ${SAVE_LAYER}/tmp #in case last boot was pupmode=12
 #adjust stack
 mount -o remount,add:1:${SAVE_LAYER}=ro+wh /pup_new
 KEEPMOUNTED="${KEEPMOUNTED}${SAVEPART} "
}

replace_dir() {
 #setup empty /tmp on tmpfs for after switch
 rm -r -f ${SAVE_LAYER}/tmp
 mkdir -p /mnt/tmpfs/tmp
 ln -s /initrd/mnt/tmpfs/tmp ${SAVE_LAYER}/tmp
 #adjust stack
 mount -o remount,prepend:${SAVE_LAYER}=rw,mod:/mnt/tmpfs/pup_rw=ro,del:/mnt/tmpfs/pup_rw /pup_new
 rm -r -f /mnt/tmpfs/pup_rw
 KEEPMOUNTED="${KEEPMOUNTED}${SAVEPART} "
}

get_fs_linux() {
# "$1" - file system type - ex: ext4
 SAVE_FS_IS_LINUX=""
 case ${1} in
  ext2|ext3|ext4|reiserfs|minix|f2fs) SAVE_FS_IS_LINUX="yes" ;;
 esac
}

search_for_save() {
# "$1" - mount point - ex:  /mnt/pdrv
# "$2" - partition name - ex: sdb2
# "$3" - file system type - ex: ext4
 if [ "$SAVE_FS_IS_LINUX" = "yes" ];then
  SAVE_FILES="$(ls -d ${1}${PSUBDIR}/${DISTRO_FILE_PREFIX}save* 2>/dev/null)"
 else
  SAVE_FILES="$(ls -d ${1}${PSUBDIR}/${DISTRO_FILE_PREFIX}save*.?fs 2>/dev/null)"
 fi
 for ONE_SAVE in $SAVE_FILES;do
  #validate savefiles here
  [ -d "$ONE_SAVE" -o -s "$ONE_SAVE" ] && PUPSAVES="${PUPSAVES}${2},${3},${PSUBDIR}/$(basename $ONE_SAVE) "
 done
}

search_func() {
 if [ "${1}" ];then
  TRY_PARTS="$(echo "$USE_PARTS" | grep -E "${1}")"
 else
  TRY_PARTS="$USE_PARTS"
 fi
 [ "$TRY_PARTS" ] || return
 for ONETRY in $TRY_PARTS;do
  ONE_PART="$(echo -n "$ONETRY" | cut -f 1 -d '|')"
  if [ "$PMEDIA" = "cd" ];then
   ensure_mounted "$ONE_PART" "/mnt/pdrv"
   [ "$ONE_MP" ] && { get_fs_linux "$ONE_FS"; search_for_save "$ONE_MP" "$ONE_PART" "$ONE_FS"; }
  fi
  find_onepupdrv "$ONE_PART" "$P_BP_FN" "$P_DEF_FN" "p"
  if [ "$ONE_FN" ];then
   PDRV="$ONE_PART,$ONE_FS,$ONE_FN"
   P_MP="$ONE_MP"
   P_PART="$ONE_PART"
   break;
  fi
  umount $ONE_MP
 done 
}

get_part_info() {
 ls -1 /sys/block | grep -E '^scd|^sd|^mmc|^sr' > /tmp/ALLDRVS0
 PCPARTSALL="$(/sbin/probepart_init -k)"
 USE_PARTS="$(echo "$PCPARTSALL" | grep '^/dev/' | cut -f 1-2 -d '|'  | grep -E 'f2fs|udf|iso9660|ext2|ext3|ext4|reiserfs|msdos|vfat|minix|ntfs' | sed -e 's%/dev/%%')"
}

umount_unneeded() {
 MTD_PARTS="$(mount | cut -f1 -d' ' | grep '^/dev' | grep -v loop | cut -f3 -d'/')"
 for ONE_PART in $MTD_PARTS;do
  [ "$(echo -n "$KEEPMOUNTED" | grep "$ONE_PART")" ] || umount /dev/$ONE_PART
 done
}

fatal_error() {
# "$1" - message - ex: puppy_tahr_6.0.5.sfs not found
 KEEPMOUNTED=""
 umount_unneeded
 echo -en "\\033[1;31m" >/dev/console #31=red
 echo -n "${1}" >/dev/console
 /bin/echo -e "\\033[0;39m" >/dev/console
 exec /bin/sh >/dev/console 2>&1
}

[ $pkeys ] && PKEYS=$pkeys #boot parameter, keyboard layout w476
#pmedia= usbflash|usbhd|usbcd|ataflash|atahd|atacd|atazip|scsihd|scsicd|cd
[ $pmedia ] && PMEDIA=$pmedia #boot parameter, broad category of boot media. ex: cd.
[ $psubdir ] && PSUBDIR=$psubdir #boot parameter, directory for puppy files. ex: puppy220
[ $psavemark ] && PSAVEMARK=$psavemark #100913 partition number that has/will-have save-file.

[ $PSUBDIR ] && [ "${PSUBDIR:0:1}" != "/" ] && PSUBDIR="/${PSUBDIR}" #add leading /.

[ $pdev1 ] && P_PART=$pdev1 #boot parameter, partition have booted off. ex: hda3
#100915 requested by technosaurus (formats get changed further down)...
[ $pdrv ] && PDRV=$pdrv #format partition:<path><filename> ex: sda2:/slacko/puppy_slacko_6.3.0.sfs
[ $pupsfs ] && PDRV=$pupsfs
[ $zdrv ] && ZDRV=$zdrv #ex: sda2:/slacko/zdrv_slacko_6.3.0.sfs
[ $fdrv ] && FDRV=$fdrv
[ $adrv ] && ADRV=$adrv
[ $ydrv ] && YDRV=$ydrv
#<partition>:<filename>, for savefile/savefolder. <partition> can be a name or Label or UUID
[ $psave ] && PSAVE=$psave #ex: sdb4:/puppy/tahr/tahrsave or smark or 49baa82d-8c69:tahrsave

#list of kernel modules to load, ex: pimod=hid-logitech-dj.ko,kernel/drivers/hid/hid-multitouch.ko 
[ $pimod ] && PIMOD=$pimod

RDSH=""
if [ "$pfix" ];then
 for ONEFIX in $(echo -n "$pfix" | tr ',' ' ')
 do
  case $ONEFIX in
   ram)     PRAMONLY="yes";;      #run in ram only (do not load ${DISTRO_FILE_PREFIX}save).
   rdsh)    RDSH="yes";;          #exit to shell in initial ramdisk.
   rdsh0)   RDSH="0";;            #drop out early, before loading drivers.
   rdsh6)   RDSH="6";;            #w091027 drop out just before mount aufs.
   nox)     PNOX="yes";;          #do not start X.
   clean)   PCLEAN="yes";;        #force version upgrade and cleanup.
   purge)   PPURGE="yes";;        #radical cleanup for broken system.
   copy)    PCOPY="yes";;         #copy .sfs files into ram.
   nocopy)  PNOCOPY="yes";;        #do not copy .sfs files into ram (default is copy if enough ram).
   fsck)    PFSCK="yes";;         #do a fsck of ${DISTRO_FILE_PREFIX}save file.
   [0-9]*)  PIGNORELAST=$ONEFIX;; #blacklist last $ONEFIX folders (multisession).
  esac
 done
fi

clear #clear the screen.
[ ! "$LOGLEVEL" ] && exec 1>/tmp/bootinit.log 2>&1 #remove o/p from console. v2.22 loglevel added.

export TZ='XXX-20'
/bin/hwclock -l -s

VFAT_OUT_PARAM='shortname=mixed,quiet,utf8'

#100915 technosaurus recommendation (see above)...
[ "$PDRV" ] && { decode_spec "$PDRV"; P_BP_ID="$ONE_BP_ID"; P_BP_FN="$ONE_BP_FN"; PDRV=""; }
[ "$ZDRV" ] && { decode_spec "$ZDRV"; Z_BP_ID="$ONE_BP_ID"; Z_BP_FN="$ONE_BP_FN"; ZDRV=""; }
[ "$FDRV" ] && { decode_spec "$FDRV"; F_BP_ID="$ONE_BP_ID"; F_BP_FN="$ONE_BP_FN"; FDRV=""; }	
[ "$ADRV" ] && { decode_spec "$ADRV"; A_BP_ID="$ONE_BP_ID"; A_BP_FN="$ONE_BP_FN"; ADRV=""; }
[ "$YDRV" ] && { decode_spec "$YDRV"; Y_BP_ID="$ONE_BP_ID"; Y_BP_FN="$ONE_BP_FN"; YDRV=""; }
[ "$PSAVE" ] && { decode_spec "$PSAVE"; SAVE_BP_ID="$ONE_BP_ID"; SAVE_BP_FN="$ONE_BP_FN"; }

#first look inside initrd...
#unset x_DEF_FN so that find_onepupdrv() won't look for it
[ -f /${P_DEF_FN} ] && { PDRV="rootfs,rootfs,/$P_DEF_FN"; P_DEF_FN=""; }
[ -f /${Z_DEF_FN} ] && { ZDRV="rootfs,rootfs,/$Z_DEF_FN"; Z_DEF_FN=""; }
[ -f /${F_DEF_FN} ] && { FDRV="rootfs,rootfs,/$F_DEF_FN"; F_DEF_FN=""; }
[ -f /${A_DEF_FN} ] && { ADRV="rootfs,rootfs,/$A_DEF_FN"; A_DEF_FN=""; }
[ -f /${Y_DEF_FN} ] && { YDRV="rootfs,rootfs,/$Y_DEF_FN"; Y_DEF_FN=""; }

get_part_info
grep -v '^sr' /tmp/ALLDRVS0 > /tmp/ATADRIVES0
ATAOPTICALDRIVES="$(grep '^sr' /tmp/ALLDRVS0 | tr '\n' ' ')"

PUPSAVES=""
KEEPMOUNTED=""
BLKIDOUT=""

decode_all_ids
if [ "${PMEDIA:0:3}" != "usb" ];then
 if [ "$P_BP_ID" = "" ];then
  if [ "$P_PART" = "" ];then
   search_func
  else
   find_onepupdrv "$P_PART" "$P_BP_FN" "$P_DEF_FN" "p"
   [ "$ONE_FN" ] && { PDRV="$ONE_PART,$ONE_FS,$ONE_FN"; P_MP="$ONE_MP"; }
  fi
 fi
fi
if [ "${PMEDIA:0:3}" = "usb" -o "$P_PART" = "" -o "$P_BP_ID" -o "$Z_BP_ID" -o "$F_BP_ID" -o "$A_BP_ID" -o "$Y_BP_ID" -o "$SAVE_BP_ID" ];then
 /sbin/wait4usb &
 while [ ! -e /tmp/flag-usb-ready ];do #wait for usb process to complete.
  usleep 250000 #microseconds
 done
 get_part_info
 USBDRVS="$(find /sys/block -maxdepth 1 -name 'sd*' -o -name 'sr*' | xargs -l readlink 2>/dev/null | grep '/usb[0-9]' | rev | cut -f 1 -d '/' | rev | tr '\n' ' ')"
 if [ "$USBDRVS" ];then
  BLKIDOUT=""
  decode_all_ids
  if [ "$P_PART" = "" ];then
   search_func "$(echo -n $USBDRVS | tr ' ' '|')"
  else
   find_onepupdrv "$P_PART" "$P_BP_FN" "$P_DEF_FN" "p"
   [ "$ONE_FN" ] && { PDRV="$ONE_PART,$ONE_FS,$ONE_FN"; P_MP="$ONE_MP"; }
  fi
 fi
fi
echo "" > /dev/console
if [ "$PDRV" = "" ];then
 fatal_error "$ONE_TRY_FN not found. Dropping out to console..."
fi

RAMSIZE=$(free | grep -o 'Mem: .*' | tr -s ' ' | cut -f 2 -d ' ') #total physical ram (less shared video). 110405

mount -t tmpfs tmpfs /mnt/tmpfs

NEWUNIONRECORD=""
COPY2RAM=""

COPYMSG='copying to ram' #purple
LOADMSG="main"
load_onepupdrv "$PDRV" "p"
if [ "$SFS_ERR" ];then
 if [ "$SFS_ERR" = "1" -a "$ONE_FN" ];then
  fatal_error "$ONE_BASENAME not Ok. Dropping out to console..."
 elif [ "$SFS_ERR" = "2" -a "$ONE_LAYER" ];then
  fatal_error "aufs $ONE_LAYER failed. Dropping out to console..."
 fi
fi
PUP_LAYER="$SFS_MP"

find_onepupdrv "$F_PART" "$F_BP_FN" "$F_DEF_FN" "f"
[ "$ONE_FN" ] && FDRV="$ONE_PART,$ONE_FS,$ONE_FN"
[ "$FDRV" ] && { LOADMSG="fdrv"; load_onepupdrv "$FDRV" "f"; }

find_onepupdrv "$Z_PART" "$Z_BP_FN" "$Z_DEF_FN" "z"
[ "$ONE_FN" ] && ZDRV="$ONE_PART,$ONE_FS,$ONE_FN"
[ "$ZDRV" ] && { LOADMSG="zdrv"; load_onepupdrv "$ZDRV" "z"; }

find_onepupdrv "$Y_PART" "$Y_BP_FN" "$Y_DEF_FN" "y"
[ "$ONE_FN" ] && YDRV="$ONE_PART,$ONE_FS,$ONE_FN"
[ "$YDRV" ] && { LOADMSG="ydrv"; load_onepupdrv "$YDRV" "y" "p"; }

find_onepupdrv "$A_PART" "$A_BP_FN" "$A_DEF_FN" "a"
[ "$ONE_FN" ] && ADRV="$ONE_PART,$ONE_FS,$ONE_FN"
[ "$ADRV" ] && { LOADMSG="adrv"; load_onepupdrv "$ADRV" "a" "p"; }

if [ "$P_PART" ];then
 BOOTDRV="$(echo -n "$P_PART" | grep -o -f /tmp/ALLDRVS0)" #110205 ex: sda1 becomes sda.
 #setup SAVEPART
 if [ "$SAVEPART" = "" ];then
  [ "$P_MP" ] || P_MP="$(mount | grep -m1 "/dev/$P_PART " | cut -f 3 -d ' ')"
  [ -f ${P_MP}${PSUBDIR}/SAVEMARK ] && PSAVEMARK="$(cat ${P_MP}${PSUBDIR}/SAVEMARK)" #partition no. that has or will-have ${DISTRO_FILE_PREFIX}save.2fs. 101020
  [ "$PSAVEMARK" ] && SAVEPART="${BOOTDRV}${PSAVEMARK}" #note, PSAVEMARK could also be a kernel boot param. ex: sda2
  [ "$SAVEPART" ] || SAVEPART="$P_PART"
 fi
fi

if [ "$SAVEPART" ];then
 #ensure that save partition is mounted
 SAVE_MP="/mnt/dev_save"
 ensure_save_mounted
fi

#initmodules stuff goes here

#find PUPSAVE, sortout pupmode
PUPMODE=5
PUPSAVE=""
if [ "$SAVE_MP" -a "$PRAMONLY" != "yes" ];then #have mounted save? partition
 #check if save partition is linux
 get_fs_linux "$SAVE_FS"
 #check for cd multisession
 if [ "$(ls -l /dev/$BOOTDRV | cut -f4 -d' ')" = "cdrom" ];then #booting on optical, is it multisession?...
  FND_MULTIFOLDER="$(find $SAVE_MP -maxdepth 1 -xdev -type d -name 20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9]-[0-9][0-9] | grep -v ' ' | sed -e 's%^/mnt/pdrv%%' | head -n 1)"
  if [ "$FND_MULTIFOLDER" ];then #multisession cd/dvd
   PUPMODE=77
   PUPSAVE="${SAVEPART},${SAVE_FS},${FND_MULTIFOLDER}"
  fi
 fi
 #check for save to partition 
 if [ "$SAVE_FS_IS_LINUX" = "yes" -a "$PSUBDIR" = "" -a -f "$SAVE_MP/etc/rc.d/PUPSTATE" ];then
  PUPMODE=6
  PUPSAVE="${SAVEPART},${SAVE_FS},/"
 fi
 #not sorted yet, may be pupmode=12
 if [ $PUPMODE -eq 5 ];then
  #check boot spec
  if [ "$SAVE_BP_FN" ];then
   if [ -d "${SAVE_MP}${SAVE_BP_FN}" ];then
    [ "$SAVE_FS_IS_LINUX" = "yes" ] && PUPSAVE="$SAVEPART,$SAVE_FS,$SAVE_BP_FN"
   else
    [ -s "${SAVE_MP}${SAVE_BP_FN}" ] && PUPSAVE="$SAVEPART,$SAVE_FS,$SAVE_BP_FN"
   fi
   [ "$PUPSAVE" ] || echo "$SAVEPART, $SAVE_BP_FN file not found." >> /tmp/bootinit.log
  else
   #have to find savefile/savefolder
   [ "$PUPSAVES" ] || search_for_save "$SAVE_MP" "$SAVEPART" "$SAVE_FS"
   if [ "$PUPSAVES" ];then
    NUMPUPSAVES=0
    for ONE_SAVE in $PUPSAVES;do
     NUMPUPSAVES=$(expr $NUMPUPSAVES + 1)
    done
    if [ $NUMPUPSAVES -eq 1 ];then
     PUPSAVE="$(echo -n $PUPSAVES)"
    elif [ $NUMPUPSAVES -gt 1 ];then
     CNTSAVE=1
     echo -e "\\033[1;36m" >/dev/console #36=aquablue
     echo "Type a number to choose which personal file to use:" > /dev/console
     echo "0  none" > /dev/console
     for ONETRY in $PUPSAVES;do
      ONE_PART="$(echo -n "$ONETRY" | cut -f 1 -d ',')"
      ONE_FILE="$(echo -n "$ONETRY" | cut -f 3 -d ',')"
      echo -e "${CNTSAVE}  ${ONE_PART}\\033[10G${ONE_FILE}" > /dev/console #10 means move to that column.
      CNTSAVE=$(expr $CNTSAVE + 1)
     done
     echo -en "\\033[0;39m" >/dev/console
     read NUMSAVE
     [ $NUMSAVE -ne 0 ] && PUPSAVE="$(echo -n $PUPSAVES | cut -f $NUMSAVE -d ' ')"
    fi
   fi
  fi
  if [ "$PUPSAVE" ];then
   PUPMODE=12
   ONE_PART="$(echo -n "$PUPSAVE" | cut -f 1 -d ',')"
   [ "$ONE_PART" != "$SAVEPART" ] && { SAVEPART="$ONE_PART"; ensure_save_mounted; }
  fi
 fi
fi

SAVE_LAYER=""
if [ "$PUPSAVE" ];then #refine pupmode
 if [ $PUPMODE -eq 6 -o $PUPMODE -eq 12 ];then
  if [ "${PMEDIA:3}" = "flash" ];then
   PUPMODE=$(expr $PUPMODE + 1)
   SAVE_LAYER="/pup_ro1"
  else
   SAVE_LAYER="/pup_rw"
  fi
 fi
fi

#load savefile if required, then setup stack
case $PUPMODE in
 77) #load folders
  copy_folders
  prepend_dir
 ;;
 13) #prepend ro1
  load_save_file
  [ "$PUPSAVE" ] && prepend_dir
 ;;
 12) #replace rw
  load_save_file
  [ "$PUPSAVE" ] && replace_dir
 ;;
 7) #prepend ro1
  load_save_part
  prepend_dir
 ;;
 6) #replace rw
  load_save_part
  replace_dir
 ;;
 5)
  SAVE_MP=""
 ;;
esac

umount_unneeded

[ "$DEV1FS" ] || DEV1FS="$(echo "$PDRV" | cut -f 2 -d ',')"
[ "$ATADRIVES" ] || ATADRIVES="$(cat /tmp/ATADRIVES0 | tr '\n' ' ')"
mkdir -p /pup_new/etc/rc.d
echo "PUPMODE=$PUPMODE" > /pup_new/etc/rc.d/PUPSTATE
echo "PDEV1='$P_PART'" >> /pup_new/etc/rc.d/PUPSTATE
echo "DEV1FS='$DEV1FS'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PUPSFS='$PDRV'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PUPSAVE='$PUPSAVE'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PMEDIA='$PMEDIA'" >> /pup_new/etc/rc.d/PUPSTATE
echo '#ATADRIVES is all internal ide/pata/sata drives, excluding optical, excluding usb...' >> /pup_new/etc/rc.d/PUPSTATE
echo "ATADRIVES='$ATADRIVES'"  >> /pup_new/etc/rc.d/PUPSTATE
echo '#ATAOPTICALDRIVES is list of non-usb optical drives...'  >> /pup_new/etc/rc.d/PUPSTATE #110206
echo "ATAOPTICALDRIVES='$ATAOPTICALDRIVES'"  >> /pup_new/etc/rc.d/PUPSTATE
echo '#these directories are unionfs/aufs layers in /initrd...' >> /pup_new/etc/rc.d/PUPSTATE
echo "SAVE_LAYER='$SAVE_LAYER'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PUP_LAYER='$PUP_LAYER'" >> /pup_new/etc/rc.d/PUPSTATE
echo "#The partition that has the ${DISTRO_FILE_PREFIX}save file is mounted here..." >> /pup_new/etc/rc.d/PUPSTATE
echo "PUP_HOME='$SAVE_MP'" >> /pup_new/etc/rc.d/PUPSTATE
echo '#(in /initrd) ...note, /mnt/home is a link to it.' >> /pup_new/etc/rc.d/PUPSTATE
echo '#this file has extra kernel drivers and firmware...' >> /pup_new/etc/rc.d/PUPSTATE
echo "ZDRV='$ZDRV'" >> /pup_new/etc/rc.d/PUPSTATE #v2.22
echo "FDRV='$FDRV'" >> /pup_new/etc/rc.d/PUPSTATE
echo "ADRV='$ADRV'" >> /pup_new/etc/rc.d/PUPSTATE 
echo "YDRV='$YDRV'" >> /pup_new/etc/rc.d/PUPSTATE
echo '#Partition no. override on boot drive to which session is (or will be) saved...' >> /pup_new/etc/rc.d/PUPSTATE
echo "PSAVEMARK='$PSAVEMARK'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PSAVEPART='$PSAVEPART'" >> /pup_new/etc/rc.d/PUPSTATE
echo "PSUBDIR='$PSUBDIR'" >> /pup_new/etc/rc.d/PUPSTATE #120215

if [ "$PUPSAVE" ];then
 xBOOTCONFIG="`grep -v '^PREVUNIONRECORD' /pup_new/etc/rc.d/BOOTCONFIG | sed -e 's/^LASTUNIONRECORD/PREVUNIONRECORD/'`"
 echo "$xBOOTCONFIG" > /pup_new/etc/rc.d/BOOTCONFIG
 echo "LASTUNIONRECORD='$(echo -n $NEWUNIONRECORD)'" >> /pup_new/etc/rc.d/BOOTCONFIG
else
 echo "" > /pup_new/etc/rc.d/BOOTCONFIG
 echo "LASTUNIONRECORD=''" >> /pup_new/etc/rc.d/BOOTCONFIG
fi

echo -n "Performing a 'switch_root' to the layered filesystem..." > /dev/console
for ONEMNT in `mount | cut -f 3 -d ' ' | grep -v 'pup_new' | grep '^/pup_' | tr '\n' ' '`;do
 mkdir -p /pup_new/initrd${ONEMNT}
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done
for ONEMNT in `mount | cut -f 3 -d ' ' | grep '^/mnt/' | tr '\n' ' '`;do
 mkdir -p /pup_new/initrd${ONEMNT}
 mount -o move $ONEMNT /pup_new/initrd${ONEMNT}
done

if [ "$PUPSAVE" ];then
 if [ "$SAVE_LAYER" -a -L "$SAVE_LAYER" ];then
  rm -r -f "/pup_new/initrd${SAVE_LAYER}"
  ln -s "/initrd${SAVE_FN}" "/pup_new/initrd${SAVE_LAYER}" #for after switch
 fi
fi
if [ -d "/pup_new/initrd/mnt/tmpfs/pup_rw" ];then
  rm -r -f /pup_new/initrd/pup_rw
  ln -s /initrd/mnt/tmpfs/pup_rw /pup_new/initrd/pup_rw #for after switch
fi

#PNOX is a boot param. /etc/profile prevents X from starting if this file exists...
[ "$PNOX" = "yes" ] && touch /pup_new/tmp/bootcnt.txt
cp -a /DISTRO_SPECS /pup_new/initrd/
cp -a /DISTRO_SPECS /pup_new/etc #james - so we don't duplicate in main SFS
cp /init /pup_new/initrd/
chmod -x /pup_new/initrd/init

[ -d "/pup_new/initrd/tmp" ] && rm -r -f /pup_new/initrd/tmp
mkdir -p /pup_new/initrd/tmp
cp -af /tmp/* /pup_new/initrd/tmp/ #keep any log files.

if [ "$RDSH" = "yes" ];then
 echo > /dev/console
 echo "Dropped to initramfs shell. Type 'exec switch' to continue booting Puppy." > /dev/console
 exec /bin/sh >/dev/console 2>&1
fi

sync
#killall -USR1 hotplug2 #v423
[ -d "/proc/bus/usb" ] && umount /proc/bus/usb
umount /sys
umount /dev
umount /proc

#now using cpio archive for initramfs 'initial ramdisk'...
exec switch_root /pup_new /sbin/init

###END###
