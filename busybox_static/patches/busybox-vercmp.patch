diff -Naur busybox-1.24.2/miscutils/vercmp.c busybox-1.24.2-patched/miscutils/vercmp.c
--- busybox-1.24.2/miscutils/vercmp.c	1970-01-01 00:00:00.000000000 +0000
+++ busybox-1.24.2-patched/miscutils/vercmp.c	2016-05-23 13:22:03.000000000 +0000
@@ -0,0 +1,157 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * libdpkg - Debian packaging suite library routines
+ * vercmp.c - comparison of version numbers
+ * 
+ * Copyright (C) 1995 Ian Jackson <iwj10@cus.cam.ac.uk>
+ *
+ * Licensed under GPLv2, see file LICENSE in this source tree
+ */
+
+//applet:IF_VERCMP(APPLET(vercmp, BB_DIR_BIN, BB_SUID_DROP))
+
+//kbuild:lib-$(CONFIG_VERCMP) += vercmp.o
+
+//config:config VERCMP
+//config:	bool "vercmp"
+//config:	default y
+//config:	help
+//config:	  Compare version strings
+//config:	  (As in Puppy vercmp)
+
+//usage:#define vercmp_trivial_usage
+//usage:	"version1 lt|gt|le|ge|eq version2\n       return value 0 if true, else 1"
+//usage:#define vercmp_full_usage "\n\n"
+//usage:	""
+
+#include "libbb.h" 
+//#include <stdio.h>
+//#include <stdlib.h>
+//#include <ctype.h>
+//#include <string.h>
+
+# define _(Text) Text
+
+struct _version_t {
+	unsigned long epoch;
+	char version[50];
+};  
+
+static int verrevcmp(const char *val, const char *ref) 
+{
+	int vc, rc;
+	long vl, rl;
+	const char *vp, *rp;
+	const char *vsep, *rsep;
+
+	if (!val) val= "";
+	if (!ref) ref= "";
+	for (;;) {
+		vp= val;  while (*vp && !isdigit(*vp)) vp++;
+		rp= ref;  while (*rp && !isdigit(*rp)) rp++;
+		for (;;) {
+			vc= val == vp ? 0 : *val++;
+			rc= ref == rp ? 0 : *ref++;
+			if (!rc && !vc) break;
+			if (vc && !isalpha(vc)) vc += 256; /* assumes ASCII character set */
+			if (rc && !isalpha(rc)) rc += 256;
+			if (vc != rc) return vc - rc;
+		}
+		val= vp;
+		ref= rp;
+		vl=0;  if (isdigit(*vp)) vl= strtol(val,(char**)&val,10);
+		rl=0;  if (isdigit(*rp)) rl= strtol(ref,(char**)&ref,10);
+		if (vl != rl) return vl - rl;
+
+		vc = *val;
+		rc = *ref;
+		vsep = strchr(".-", vc);
+		rsep = strchr(".-", rc);
+		if (vsep && !rsep) return -1;
+		if (!vsep && rsep) return +1;
+
+		if (!*val && !*ref) return 0;
+		if (!*val) return -1;
+		if (!*ref) return +1;
+	}
+}
+
+static int versioncompare(const struct _version_t *version,
+                   const struct _version_t *refversion) 
+{
+	if (version->epoch > refversion->epoch) return 1;
+	if (version->epoch < refversion->epoch) return -1;
+	return verrevcmp(version->version,refversion->version);
+}
+
+static int versionsatisfied3(const struct _version_t *it,
+                      const struct _version_t *ref,
+                      const char *op) 
+{
+	int r;
+	r= versioncompare(it,ref);
+	if (strcmp(op, "le") == 0 || strcmp(op, "=<") == 0)
+		return r <= 0;
+	if (strcmp(op, "ge") == 0 || strcmp(op, ">=") == 0)
+		return r >= 0;
+	if (strcmp(op, "lt") == 0 || strcmp(op, "<") == 0)
+		return r < 0;
+	if (strcmp(op, "gt") == 0 || strcmp(op, ">") == 0)
+		return r > 0;
+	if (strcmp(op, "eq") == 0 || strcmp(op, "=") == 0)
+		return r == 0;
+	fprintf(stderr, "unknown operator: %s", op);
+	exit(1);
+}
+
+static const char *parseversion(struct _version_t *rversion, const char *string) 
+{
+	char *colon, *eepochcolon;
+	unsigned long epoch;
+	if (!*string) return _("version string is empty");
+	colon= strchr(string,':');
+	if (colon) {
+		epoch= strtoul(string,&eepochcolon,10);
+		if (colon != eepochcolon) return _("epoch in version is not number");
+			if (!*++colon) return _("nothing after colon in version number");
+				string= colon;
+				rversion->epoch= epoch;
+	} else {
+		rversion->epoch= 0;
+	}
+	snprintf(rversion->version, sizeof(char)*50, "%s", string);
+	return 0;
+}
+
+//int main(int argc, char *argv[])
+int vercmp_main (int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
+int vercmp_main (int argc, char **argv)
+{
+	const char *err;
+	struct _version_t ver, ref;
+	int res;
+	if (argc < 4) {
+		fprintf(stderr, "usage: %s version1 lt|gt|le|ge|eq version2\n       return value 0 if true, else 1\n", argv[0]);
+		return 2;
+	}
+	err = parseversion(&ver, argv[1]);
+	if (err) {
+		fprintf(stderr, "Invalid version `%s': %s\n", argv[1], err);
+		return 2;
+	}
+	err = parseversion(&ref, argv[3]);
+	if (err) {
+		fprintf(stderr, "Invalid version `%s': %s\n", argv[3], err);
+		return 2;
+	}
+	res = (! versionsatisfied3(&ver, &ref, argv[2]));
+	if (argc > 4 && *argv[4] == 'd') {
+		printf("'epoch' 'ver'\n");
+		printf("'%d' '%s'\n", ver.epoch, ver.version);
+		printf("'%d' '%s'\n", ref.epoch, ref.version);
+		printf("exit code: %d\n",res);
+	}
+	return res;
+}
+
+/* END */
